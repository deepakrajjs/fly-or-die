<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fly or Die - Arcade Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Fly or Die - Modern Arcade Game">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Orbitron:700,400|Roboto:400,700">
  <style>
    :root {
      --main-bg: #222831;
      --accent: #00adb5;
      --danger: #ff2e63;
      --good: #eaffd0;
      --score: #ffd700;
    }
    body {
      margin: 0;
      background: var(--main-bg);
      font-family: 'Roboto', Arial, sans-serif;
      color: #fff;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: hidden;
    }
    #game-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    canvas {
      border-radius: 16px;
      box-shadow: 0 4px 32px #000a;
      background: #393e46;
      width: 100vw;
      height: 100vh;
      max-width: 480px;
      max-height: 720px;
      touch-action: none;
    }
    #ui-overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #main-menu, #level-complete, #game-over, #leaderboard {
      background: #393e46ee;
      border-radius: 16px;
      box-shadow: 0 2px 16px #0007;
      padding: 32px 24px;
      margin-top: 64px;
      pointer-events: auto;
      text-align: center;
      min-width: 250px;
      display: none;
    }
    .visible { display: block !important; }
    h1 {
      font-family: 'Orbitron', Arial, sans-serif;
      color: var(--accent);
      font-size: 2.2rem;
      margin-bottom: 0.5em;
      text-shadow: 0 2px 8px #0009;
    }
    .btn {
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 1.2em;
      padding: 10px 26px;
      margin: 8px 0;
      font-family: 'Orbitron', Arial, sans-serif;
      cursor: pointer;
      transition: background 0.2s;
      pointer-events: auto;
    }
    .btn:hover { background: var(--danger);}
    #scoreboard, #level-indicator, #mute-btn {
      position: absolute;
      font-size: 1.1em;
      background: #222831cc;
      border-radius: 8px;
      padding: 6px 14px;
      left: 14px;
      top: 14px;
      z-index: 2;
      color: var(--score);
      pointer-events: auto;
      box-shadow: 0 2px 10px #0002;
    }
    #level-indicator { left: unset; right: 14px; color: var(--accent);}
    #mute-btn {
      left: unset; right: 14px; top: 54px;
      background: #00adb522;
      color: #fff; font-size: 1.3em; border: none; cursor: pointer;
      padding: 6px 10px; z-index: 3;
    }
    @media (max-width: 600px) {
      canvas { max-width: 100vw; max-height: 80vh;}
      #main-menu, #level-complete, #game-over, #leaderboard { margin-top: 20px;}
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas" width="480" height="720"></canvas>
    <div id="ui-overlay">
      <div id="main-menu" class="visible">
        <h1>Fly or Die</h1>
        <p>Arcade Challenge - Tap or click to fly!</p>
        <button class="btn" id="start-btn">Start Game</button>
        <button class="btn" id="show-lb-btn">Leaderboard</button>
        <p style="margin-top:1em; font-size:.95em;">v1.0 | &copy; 2025 deepakrajjs</p>
      </div>
      <div id="level-complete">
        <h1>Level Complete!</h1>
        <p id="next-level-info"></p>
        <button class="btn" id="next-level-btn">Next Level</button>
      </div>
      <div id="game-over">
        <h1>Game Over</h1>
        <p id="final-score"></p>
        <button class="btn" id="restart-btn">Restart</button>
        <button class="btn" id="show-lb-btn-over">Leaderboard</button>
      </div>
      <div id="leaderboard">
        <h1>Leaderboard</h1>
        <ol id="lb-list"></ol>
        <button class="btn" id="close-lb-btn">Back</button>
      </div>
    </div>
    <div id="scoreboard">Score: 0</div>
    <div id="level-indicator">Level: 1</div>
    <button id="mute-btn" title="Mute/Unmute Sound">ðŸ”Š</button>
  </div>
  <script>
    // --- Game Variables ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    let width = canvas.width, height = canvas.height;
    let devicePixelRatio = window.devicePixelRatio || 1;

    // UI Elements
    const mainMenu = document.getElementById('main-menu');
    const startBtn = document.getElementById('start-btn');
    const nextLevelDiv = document.getElementById('level-complete');
    const nextLevelBtn = document.getElementById('next-level-btn');
    const nextLevelInfo = document.getElementById('next-level-info');
    const gameOverDiv = document.getElementById('game-over');
    const finalScoreEl = document.getElementById('final-score');
    const restartBtn = document.getElementById('restart-btn');
    const scoreboard = document.getElementById('scoreboard');
    const levelIndicator = document.getElementById('level-indicator');
    const muteBtn = document.getElementById('mute-btn');
    const lbDiv = document.getElementById('leaderboard');
    const lbList = document.getElementById('lb-list');
    const showLbBtn = document.getElementById('show-lb-btn');
    const showLbBtnOver = document.getElementById('show-lb-btn-over');
    const closeLbBtn = document.getElementById('close-lb-btn');

    // Game State
    let running = false, gameOver = false, paused = false, level = 1, score = 0, highScores = [];
    let mute = false, requestId = null;

    // --- Sound Effects ---
    const SFX = {
      flap: new Audio('https://cdn.pixabay.com/audio/2022/07/26/audio_12c6b4ba6e.mp3'),
      die: new Audio('https://cdn.pixabay.com/audio/2022/07/26/audio_12c6b4ba6e.mp3'),
      score: new Audio('https://cdn.pixabay.com/audio/2022/07/26/audio_12c6b4ba6e.mp3'),
      levelUp: new Audio('https://cdn.pixabay.com/audio/2022/07/26/audio_12c6b4ba6e.mp3'),
      powerup: new Audio('https://cdn.pixabay.com/audio/2022/07/26/audio_12c6b4ba6e.mp3'),
    };
    function playSFX(name) {
      if (!mute && SFX[name]) { SFX[name].currentTime = 0; SFX[name].play(); }
    }

    muteBtn.onclick = () => {
      mute = !mute;
      muteBtn.textContent = mute ? 'ðŸ”‡' : 'ðŸ”Š';
    };

    // --- Responsive Canvas ---
    function resizeCanvas() {
      let w = Math.min(window.innerWidth, 480);
      let h = Math.min(window.innerHeight, 720);
      devicePixelRatio = window.devicePixelRatio || 1;
      canvas.width = w * devicePixelRatio;
      canvas.height = h * devicePixelRatio;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      width = canvas.width;
      height = canvas.height;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- Leaderboard ---
    function loadLeaderboard() {
      try {
        highScores = JSON.parse(localStorage.getItem('flyordie-lb') || '[]');
      } catch { highScores = []; }
    }
    function saveLeaderboard() {
      localStorage.setItem('flyordie-lb', JSON.stringify(highScores));
    }
    function showLeaderboard() {
      lbDiv.classList.add('visible');
      mainMenu.classList.remove('visible');
      gameOverDiv.classList.remove('visible');
      lbList.innerHTML = '';
      loadLeaderboard();
      let html = '';
      highScores.slice(0, 10).forEach(({score, level}, i) => {
        html += `<li>#${i+1}: <b>${score}</b> pts - Level ${level}</li>`;
      });
      lbList.innerHTML = html || '<li>No scores yet. Play to set a record!</li>';
    }
    showLbBtn.onclick = showLeaderboard;
    showLbBtnOver.onclick = showLeaderboard;
    closeLbBtn.onclick = () => {
      lbDiv.classList.remove('visible');
      mainMenu.classList.add('visible');
    };

    // --- Game Entities ---
    class Player {
      constructor() {
        this.x = width / 5;
        this.y = height / 2;
        this.r = 20 * devicePixelRatio;
        this.vy = 0;
        this.gravity = 0.6 * devicePixelRatio;
        this.flap = -9 * devicePixelRatio;
        this.color = '#00adb5';
        this.alive = true;
        this.powered = false;
        this.powerTimer = 0;
      }
      draw() {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = this.alive ? (this.powered ? '#eaffd0' : this.color) : '#ff2e63';
        ctx.shadowColor = this.powered ? '#eaffd0' : this.color;
        ctx.shadowBlur = this.powered ? 24 : 10;
        ctx.fill();
        ctx.restore();
      }
      update() {
        if (!this.alive) return;
        this.vy += this.gravity;
        this.y += this.vy;
        if (this.powered) {
          this.powerTimer--;
          if (this.powerTimer <= 0) this.powered = false;
        }
      }
      flapUp() {
        if (!this.alive) return;
        this.vy = this.flap;
        playSFX('flap');
      }
      powerUp() {
        this.powered = true;
        this.powerTimer = 120; // 2s at 60fps
        playSFX('powerup');
      }
    }

    class Obstacle {
      constructor(gapY, gapH) {
        this.x = width + 50 * devicePixelRatio;
        this.w = 40 * devicePixelRatio;
        this.gapY = gapY;
        this.gapH = gapH;
        this.speed = 4 + level * 0.7;
        this.passed = false;
      }
      update() {
        this.x -= this.speed * devicePixelRatio;
      }
      draw() {
        ctx.save();
        ctx.fillStyle = '#ff2e63';
        // Top pipe
        ctx.fillRect(this.x, 0, this.w, this.gapY - this.gapH / 2);
        // Bottom pipe
        ctx.fillRect(this.x, this.gapY + this.gapH / 2, this.w, height - this.gapY - this.gapH / 2);
        ctx.restore();
      }
      offScreen() { return this.x + this.w < 0; }
    }

    class PowerUp {
      constructor() {
        this.x = width + 50 * devicePixelRatio;
        this.y = Math.random() * (height - 60 * devicePixelRatio) + 30 * devicePixelRatio;
        this.r = 14 * devicePixelRatio;
        this.speed = 4 + level * 0.7;
        this.collected = false;
      }
      update() { this.x -= this.speed * devicePixelRatio; }
      draw() {
        ctx.save();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = '#ffd700';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 16;
        ctx.fill();
        ctx.restore();
      }
      offScreen() { return this.x + this.r < 0; }
    }

    // --- Game Logic ---
    let player, obstacles, powerUps, frameCount, scoreThisLevel, nextPowerSpawn;

    function resetGameVars(levelNum=1) {
      player = new Player();
      obstacles = [];
      powerUps = [];
      frameCount = 0;
      scoreThisLevel = 0;
      nextPowerSpawn = Math.floor(Math.random()*120) + 180;
      level = levelNum;
      running = true;
      paused = false;
      gameOver = false;
      scoreboard.textContent = `Score: ${score}`;
      levelIndicator.textContent = `Level: ${level}`;
    }

    function startGame() {
      mainMenu.classList.remove('visible');
      gameOverDiv.classList.remove('visible');
      nextLevelDiv.classList.remove('visible');
      lbDiv.classList.remove('visible');
      score = 0;
      resetGameVars(1);
      requestId = requestAnimationFrame(gameLoop);
    }

    function nextLevel() {
      nextLevelDiv.classList.remove('visible');
      score += scoreThisLevel;
      resetGameVars(level + 1);
      playSFX('levelUp');
      requestId = requestAnimationFrame(gameLoop);
    }

    function endGame() {
      running = false;
      gameOver = true;
      player.alive = false;
      finalScoreEl.textContent = `Final Score: ${score} (Level ${level})`;
      gameOverDiv.classList.add('visible');
      // Save leaderboard
      loadLeaderboard();
      highScores.push({score, level});
      highScores = highScores.sort((a, b) => b.score - a.score).slice(0, 10);
      saveLeaderboard();
      playSFX('die');
    }

    startBtn.onclick = startGame;
    restartBtn.onclick = startGame;
    nextLevelBtn.onclick = nextLevel;

    // --- Controls ---
    function handleFlap(e) {
      if (!running || paused) return;
      player.flapUp();
    }
    canvas.addEventListener('mousedown', handleFlap);
    canvas.addEventListener('touchstart', handleFlap);

    // --- Game Loop ---
    function gameLoop() {
      ctx.clearRect(0, 0, width, height);
      // Background gradient
      let grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, '#393e46');
      grad.addColorStop(1, '#222831');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);

      // Draw and Update Player
      player.update();
      player.draw();

      // Spawn Obstacles
      if (frameCount % Math.max(90 - level*4, 40) === 0) {
        let gapH = Math.max(110 - level*7, 60) * devicePixelRatio;
        let gapY = Math.random() * (height - gapH*1.2) + gapH*0.6;
        obstacles.push(new Obstacle(gapY, gapH));
      }
      obstacles.forEach(o => o.update());
      obstacles.forEach(o => o.draw());
      obstacles = obstacles.filter(o => !o.offScreen());

      // Spawn PowerUp
      if (frameCount > nextPowerSpawn && Math.random() < 0.01 + level*0.001) {
        powerUps.push(new PowerUp());
        nextPowerSpawn = frameCount + Math.floor(Math.random()*150) + 200;
      }
      powerUps.forEach(p => p.update());
      powerUps.forEach(p => p.draw());
      powerUps = powerUps.filter(p => !p.offScreen());

      // Collision Detection
      obstacles.forEach(o => {
        // Player hit obstacle
        if (!o.passed && !player.powered &&
          player.x + player.r > o.x && player.x - player.r < o.x + o.w &&
          (player.y - player.r < o.gapY - o.gapH / 2 || player.y + player.r > o.gapY + o.gapH / 2)) {
            endGame();
        }
        // Count as passed
        if (!o.passed && o.x + o.w < player.x - player.r) {
          o.passed = true;
          scoreThisLevel += 1;
          scoreboard.textContent = `Score: ${score + scoreThisLevel}`;
          playSFX('score');
        }
      });
      // Player hit ground or ceiling
      if (player.y + player.r > height || player.y - player.r < 0) {
        endGame();
      }
      // PowerUp collection
      powerUps.forEach(p => {
        if (!p.collected &&
          Math.abs(player.x - p.x) < player.r + p.r &&
          Math.abs(player.y - p.y) < player.r + p.r) {
            p.collected = true;
            player.powerUp();
            scoreThisLevel += 5;
            scoreboard.textContent = `Score: ${score + scoreThisLevel}`;
        }
      });
      powerUps = powerUps.filter(p => !p.collected);

      // Particle Effects (simple)
      if (player.powered) {
        for (let i = 0; i < 8; i++) {
          let px = player.x + Math.cos(i/8*2*Math.PI)*player.r*1.2;
          let py = player.y + Math.sin(i/8*2*Math.PI)*player.r*1.2;
          ctx.beginPath();
          ctx.arc(px, py, 5 * devicePixelRatio, 0, Math.PI * 2);
          ctx.fillStyle = '#eaffd0';
          ctx.globalAlpha = 0.6;
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      // Level Progression
      if (scoreThisLevel >= 15 + level*5) {
        running = false;
        nextLevelInfo.textContent = `Get ready for Level ${level+1}!`;
        nextLevelDiv.classList.add('visible');
        score += scoreThisLevel;
        levelIndicator.textContent = `Level: ${level+1}`;
        playSFX('levelUp');
        return;
      }

      // Next Frame
      frameCount++;
      if (running && !gameOver) requestId = requestAnimationFrame(gameLoop);
    }

    // --- Init Leaderboard ---
    loadLeaderboard();
    showLbBtn.onclick = showLeaderboard;
    showLbBtnOver.onclick = showLeaderboard;

    // --- Pause Feature ---
    document.addEventListener('keydown', (e) => {
      if (e.key === 'p') {
        paused = !paused;
        if (!paused && running) requestId = requestAnimationFrame(gameLoop);
      }
    });

    // --- Show Main Menu on Load ---
    mainMenu.classList.add('visible');
  </script>
</body>
</html>
